# Mysql中多个join on(表连接)和where之间的执行顺序 

```mysql
select
	*
from
	exam_info ei
left join exam_paper ep on
	ei.exam_id = ep.exam_id
left join exam_question eq 
	on ep.paper_id = eq.paper_id
where ei.exam_id = 2
```

对于外连接，有一个主表的概念，即left的左边表或者right的右边表，对于主表，会返回主表所有符合条件的记录行，而对于副表，则只返回能和主表关联的行，一条主表记录根据on条件和副表内每一行匹配，有多少行匹配上了就生成多少临时表的记录，也就是说主表的一行记录可能生成临时表的多条记录，若副表中没有匹配行时，则副表生成一条所有字段均为null的记录和主表的记录行匹配， 确保主表的符合条件的行能进入临时表。

对于外连接，大部分情况会以我们的SQL顺序来执行，因为有主表的结果集限制，上述SQL一般会先根据WHERE条件从A表重 查询出符合条件的记录行，作为主表和B表以ON条件关联，A结果集中的每条记录均和B表中符合条件的每条记录行生成AB临时表的一条记录，若B表有多个符合记录行，则生成多个临时表行，若B表没有符合条件的行，则生成一条所有字段均为null的行与A的记录行连接，若没有ON条件，则以“笛卡尔积”的形式连接，即A结果集的每一行和B表的每一行均连接生成临时表的记录。

当ON执行完之后，同样用WHERE条件过滤临时结果集中不符合条件的记录行，和内连接的机制相同，之后再次关联其他表。最后right join D，此时D表时主动表，D表关联A,B,C查询后的临时表，最终会返回D表中所有符合条件的记录行。

以上就是**nest loop join**机制，嵌套循环连接。一层一层的连接，循环用外层结果集的记录行和内层的所有符合条件ON条件的记录依次连接，内层没有符合条件的生成所有字段为null的记录行，当不存在ON条件是以“笛卡尔积”的形式连接。连接过后where过滤，再连接，在过滤，直到左右表均连接完毕。连接完毕后有group by字句则执行分组，有having字句的则对分组后的结果集再过滤，所以having执行在where之后，因此有些条件放where字句内能缩小分组前的结果集，提高执行效率。之后还有order by字句的则执行排序，最后得到查询的结果。

## 总结：

对于left join，不管on后面跟什么条件，左表的数据全部查出来，因此要想过滤需把条件放到where后面

对于inner join，满足on后面的条件表的数据才能查出，可以起到过滤作用。也可以把条件放到where后面。