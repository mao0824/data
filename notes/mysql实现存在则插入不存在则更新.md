# mysql实现存在则插入不存在则更新

## REPLACE INTO

当数据库是 MySQL ，碰到 不存在则插入，存在则更新 的需求时，第一时间往往想到的是 REPLACE INTO

replace into 跟 insert 功能类似

不同点在于： replace into 首先尝试插入数据到表中，如果发现表中已经有此行数据（根据主键或者唯一索引判断）则**先删除此行数据，然后插入新的数据**，否则直接插入新数据

replace 语句会返回一个数，表示受影响的行的数目，该数是被删除和被插入的行数的和



#### 1、破坏外键约束

如果主键被指定成了其他表的外键，那么 replace into 更新（非插入）时影响到了其他表的外键约束，那么会执行失败，提示类似信息：

#### 2、主键加速自增

很多情况下，我们的主键是 int 或者 bigint 类型，并且设置成了自增

不管是 int 还是 bigint ，都有一个最大值，如果一直自增下去，总有一天会达到最大值（可能到地老天荒也达不到这个值）

Replace into 的更新是先删除再插入，会导致主键自增 1（照理来说，更新是不应该导致主键自增 1）

如果更新频率远远大于插入频率，本不用考虑的自增主键用完的问题，可能就需要考虑了

另外也会导致主键不连续，主键值跳跃式的出现在表中

#### 3、主从切换问题

## 总结

1、如何选择哪种方式

上述三种方式各有优略，代码处理不依赖于具体的数据库，可移植性高，也不会引入特定数据库的在这方面的缺陷

replace into 的方式不推荐（坑有点多），它完全可以由 INSERT UPDATE 替代

INSERT UPDATE 可以减少我们的代码，但它是 MySQL 的拓展实现，只有 MySQL 支持，可移植性差

2、针对 INSERT UPDATE 的 “坑”，我们可以结合具体的业务来设置 innodb_autoinc_lock_mode ，适当的避免它的 “坑”

3、道路千万条，合适第一条

